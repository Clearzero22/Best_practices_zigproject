.{
    // This is the default name used by packages depending on this one. For
    // example, when a user runs `zig fetch --save <url>`, this field is used
    // as the key in the `dependencies` table. Although the user can choose a
    // different name, most users will stick with this provided value.
    //
    // It is redundant to include "zig" in this name because it is already
    // within the Zig package namespace.
    //     这是依赖于此包的其它包所使用的默认名称。例如，当用户运行 zig fetch --save <url> 时，此字段将用作 dependencies 表中的键。尽管用户可以选择不同的名称，但大多数用户会坚持使用此提供的默认值。

    // 在此名称中包含 "zig" 是冗余的，因为它已经位于 Zig 包的命名空间内。
    .name = .Best_practices_zigproject,

    // This is a [Semantic Version](https://semver.org/).
    // In a future version of Zig it will be used for package deduplication.
    //     这段代码注释说明了在 Zig 编程语言中，如何使用语义版本（Semantic Version）来标记包的版本。以下是对这段注释的翻译和解释：

    // 这是一个语义版本。在 Zig 的未来版本中，它将用于包去重。

    // 语义版本：语义版本是一种版本控制方案，通常遵循“主版本号.次版本号.修订号”的格式。它提供了一种标准化的方式来表达软件版本，并传达版本间的兼容性信息。

    // 包去重：在软件工程中，包去重是指识别并消除项目中重复的依赖包。这有助于减少项目的复杂性，避免潜在的错误，并可能优化项目的构建时间和资源消耗。

    // 未来版本的使用：注释提到，在 Zig 的未来版本中，语义版本将被用于包去重。这意味着 Zig 工具链将能够识别具有相同语义版本的包，并自动处理重复的依赖，以确保每个包只被包含一次。

    // 总的来说，这段注释说明了 Zig 编程语言中包的语义版本控制的重要性，并预告了未来 Zig 版本中将如何利用语义版本信息来优化包管理。
    .version = "0.0.0",

    // Together with name, this represents a globally unique package
    // identifier. This field is generated by the Zig toolchain when the
    // package is first created, and then *never changes*. This allows
    // unambiguous detection of one package being an updated version of
    // another.
    //     这段代码注释说明了在 Zig 编程语言中，如何使用一个字段来表示一个全局唯一的包标识符。以下是对这段注释的翻译和解释：

    // 与名称一起，这代表了全局唯一的包标识符。当包首次创建时，这个字段由 Zig 工具链生成，并且之后永远不会改变。这允许明确地检测一个包是否是另一个包的更新版本。

    // 全局唯一性：这段注释强调了字段与包名称一起构成了一个全球唯一的标识符。这意味着无论包在哪里被使用或分发，这个标识符都能确保它是唯一的。

    // 生成与不变性：标识符是在包首次创建时由 Zig 工具链自动生成的。一旦生成，这个标识符就不会再改变。这种不变性对于跟踪包的版本和更新非常重要。

    // 版本控制：通过使用这个唯一的标识符，可以清楚地判断一个包是否是另一个包的新版本。这对于包的管理和依赖性维护至关重要。

    // 总的来说，这段注释说明了 Zig 编程语言中包标识符的重要性和特性，以及它是如何帮助管理包的版本和依赖关系的。
    //     //
    // When forking a Zig project, this id should be regenerated (delete the
    // field and run `zig build`) if the upstream project is still maintained.
    // Otherwise, the fork is *hostile*, attempting to take control over the
    // original project's identity. Thus it is recommended to leave the comment
    // on the following line intact, so that it shows up in code reviews that
    // modify the field.

    // 当派生（fork）一个 Zig 项目时，如果上游项目仍在维护，
    // 则应该重新生成此 ID（删除该字段并运行 zig build）。否则，该派生是“敌意的”，
    // 试图控制原始项目的身份。因此，建议保留下一行的注释不变，以便在修改该字段的代
    // 码审查中显示出来。
    .fingerprint = 0x306f4020c187d16b, // Changing this has security and trust implications.

    // Tracks the earliest Zig version that the package considers to be a
    // supported use case.
    // ：记录了这个软件包认为最早的、可以支持正常使用的 Zig 版本。
    .minimum_zig_version = "0.15.1",

    // This field is optional.
    // Each dependency must either provide a `url` and `hash`, or a `path`.
    // `zig build --fetch` can be used to fetch all dependencies of a package, recursively.
    // Once all dependencies are fetched, `zig build` no longer requires
    // internet connectivity.
    // 这个字段是可选的。
    // 每个依赖项必须提供一个 `url` 和 `hash`，或者一个 `path`。
    // 可以使用 `zig build --fetch` 递归地获取一个包的所有依赖项。
    // 一旦所有依赖项都被获取，`zig build` 就不再需要网络连接。
    .dependencies = .{
        .zig_webui = .{
            .url = "https://github.com/webui-dev/zig-webui/archive/main.tar.gz",
            .hash = "zig_webui-2.5.0-beta.4-M4z7zSVGAQDjebIHUheRN0UN8TFFc0XySFLOglG437n8",
        },
    },
    .paths = .{
        "build.zig",
        "build.zig.zon",
        "src",
        // For example...
        //"LICENSE",
        //"README.md",
    },
}
