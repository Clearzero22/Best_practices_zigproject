ABI
An ABI (application binary interface) is a standard, pertaining to:
ABI（应用程序二进制接口） 是一种标准，涉及：

The in-memory layout of types (i.e. a type's size, alignment, offsets, and the layouts of its fields)
类型的内存布局（即类型的大小、对齐方式、偏移量及其字段的布局）
The in-linker naming of symbols (e.g. name mangling)
符号的链接器内命名（例如名称修改）
The calling conventions of functions (i.e. how a function call works at a binary level)
函数的调用约定（即函数调用在二进制级别的工作方式）
By defining these rules and not breaking them, an ABI is said to be stable, and this can be used to, for example, reliably link together multiple libraries, executables, or objects which were compiled separately (potentially on different machines or using different compilers). This allows for FFI (foreign function interface) to take place, where we can share code between programming languages.
通过定义这些规则而不破坏它们，ABI 被认为是稳定的，例如，这可用于可靠地将单独编译的多个库、可执行文件或对象链接在一起（可能在不同的机器上或使用不同的编译器）。这允许发生 FFI（外部函数接口）， 我们可以在编程语言之间共享代码。

Zig natively supports C ABIs for extern things; which C ABI is used depends on the target you are compiling for (e.g. CPU architecture, operating system). This allows for near-seamless interoperation with code that was not written in Zig; the usage of C ABIs is standard amongst programming languages.
Zig 原生支持 C ABI 用于外部事物;使用哪种 C ABI 取决于您要编译的目标（例如 CPU 架构、作系统）。这允许与不是用 Zig 编写的代码进行近乎无缝的互作;C ABI 的使用是编程语言中的标准。

Zig internally does not use an ABI, meaning code should explicitly conform to a C ABI where reproducible and defined binary-level behaviour is needed.
Zig 内部不使用 ABI，这意味着代码应该显式符合需要可重现和定义的二进制级行为的 C ABI。